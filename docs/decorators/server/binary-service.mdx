---
title: 'BinaryService'
---
import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

## Description

`BinaryService` declares a **native external binary service** managed by OpenCore.

A BinaryService represents a **persistent operating system process** executed outside the FiveM runtime, allowing heavy or sensitive logic to run in complete isolation while being consumed from TypeScript as normal asynchronous methods.

Binary services communicate with OpenCore using a simple **JSON-based RPC protocol** over `stdin` / `stdout`.

This system is language-agnostic and can be implemented in any language capable of reading from standard input and writing to standard output.

Typical use cases include:

- CPU-intensive operations
- cryptography and hashing
- pathfinding
- data processing
- native integrations
- sandboxed logic execution 

Part of our team created libraries to easily and seamlessly use the protocol with Go and Rust; you can download them here.
- **Go**: [Github](https://github.com/Flussen/opencore-jsonrpc-go) - [pkg.go.dev](https://pkg.go.dev/github.com/Flussen/opencore-jsonrpc-go)
  - `go get github.com/Flussen/opencore-jsonrpc-go`
- **Rust**: [Github](https://github.com/Flussen/opencore-jsonrpc-rust) - [crates.io](https://crates.io/crates/opencore-jsonrpc-rust)
  - `cargo install opencore-jsonrpc-rust`
---

## Arguments

```ts
@Server.BinaryService(options)
```

### `options.name`

Logical identifier of the service inside OpenCore.

This name is used to route binary calls and must be unique per resource.

```ts
name: 'math'
```

### `options.binary`

Logical binary filename (without extension).

> The framework resolves the correct executable automatically depending on the platform

Examples:

* Windows → `math.exe`
* Linux → `math`

```ts
binary: 'math'
```

### `options.timeoutMs` (optional)

Default timeout for binary calls in milliseconds.

If the binary does not respond within this time, the call is rejected automatically.

```ts
timeoutMs: 2000
```

## How the API works

When a method decorated with `@BinaryCall` is invoked:

1. OpenCore sends a JSON message to the binary process via `stdin`
2. The binary processes the request
3. A JSON response is written to `stdout`
4. OpenCore resolves or rejects the corresponding Promise

The binary process is spawned **once** and kept alive for the entire resource lifecycle.

---

## Binary Protocol

### Request

```json
{
  "id": "uuid",
  "action": "sum",
  "params": [2, 3]
}
```

* `id` is generated by OpenCore
* `action` identifies the operation
* `params` contains positional arguments

---

### Success response

```json
{
  "id": "uuid",
  "status": "ok",
  "result": 5
}
```

---

### Error response

```json
{
  "id": "uuid",
  "status": "error",
  "error": "invalid parameters"
}
```

---

## Example

### TypeScript (OpenCore consumer)

```ts
import { Server } from '@open-core/framework/server'

@Server.BinaryService({
  name: 'math',
  binary: 'math',
  timeoutMs: 2000,
})
export class MathBinaryService {

  @Server.BinaryCall({ action: 'sum' })
  sum(a: number, b: number): Promise<number> {
    throw new Error('BinaryCall proxy')
    // or return null as any
  }
}
```

Usage:

```ts
const result = await mathService.sum(2, 3)
// result === 5
```

---

## Binary Implementation Example

The following example demonstrates a minimal binary compatible with OpenCore.

This binary listens on `stdin`, processes JSON requests, and responds on `stdout`.

<Tabs>
  <TabItem value="go" label="Go">

```go
package main

import (
	"bufio"
	"encoding/json"
	"os"
	"strings"
)

type Request struct {
	ID     string        `json:"id"`
	Action string        `json:"action"`
	Params []interface{} `json:"params"`
}

type Response struct {
	ID     string      `json:"id"`
	Status string      `json:"status"`
	Result interface{} `json:"result,omitempty"`
	Error  string      `json:"error,omitempty"`
}

func main() {
	reader := bufio.NewReader(os.Stdin)

	for {
		line, err := reader.ReadString('\n')
		if err != nil {
			return
		}

		line = strings.TrimSpace(line)
		if line == "" {
			continue
		}

		var req Request
		if err := json.Unmarshal([]byte(line), &req); err != nil {
			continue
		}

		switch req.Action {
		case "sum":
			if len(req.Params) != 2 {
				sendError(req.ID, "invalid params")
				continue
			}

			a, ok1 := req.Params[0].(float64)
			b, ok2 := req.Params[1].(float64)
			if !ok1 || !ok2 {
				sendError(req.ID, "params must be numbers")
				continue
			}

			sendOK(req.ID, int(a+b))
		default:
			sendError(req.ID, "unknown action")
		}
	}
}

func sendOK(id string, result any) {
	resp := Response{ID: id, Status: "ok", Result: result}
	data, _ := json.Marshal(resp)
	os.Stdout.Write(append(data, '\n'))
}

func sendError(id string, msg string) {
	resp := Response{ID: id, Status: "error", Error: msg}
	data, _ := json.Marshal(resp)
	os.Stdout.Write(append(data, '\n'))
}
```
  </TabItem>
  <TabItem value="cpp" label="C++">

```cpp
#include <iostream>
#include <string>
#include <nlohmann/json.hpp>

using json = nlohmann::json;

int main() {
    std::string line;

    while (std::getline(std::cin, line)) {
        if (line.empty()) continue;

        json req;
        try {
            req = json::parse(line);
        } catch (...) {
            continue;
        }

        std::string id = req.value("id", "");
        std::string action = req.value("action", "");

        if (action == "sum") {
            if (!req.contains("params") || req["params"].size() != 2) {
                std::cout << json{
                    {"id", id},
                    {"status", "error"},
                    {"error", "invalid params"}
                } << std::endl;
                continue;
            }

            int a = req["params"][0];
            int b = req["params"][1];

            std::cout << json{
                {"id", id},
                {"status", "ok"},
                {"result", a + b}
            } << std::endl;
        } else {
            std::cout << json{
                {"id", id},
                {"status", "error"},
                {"error", "unknown action"}
            } << std::endl;
        }
    }

    return 0;
}
```

**Dependencies**

```bash
# nlohmann/json (single-header)
https://github.com/nlohmann/json
```

  </TabItem>

  <TabItem value="rust" label="Rust">

```rust
use std::io::{self, BufRead};
use serde::{Deserialize, Serialize};

#[derive(Deserialize)]
struct Request {
    id: String,
    action: String,
    params: Vec<f64>,
}

#[derive(Serialize)]
struct Response<T> {
    id: String,
    status: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    result: Option<T>,
    #[serde(skip_serializing_if = "Option::is_none")]
    error: Option<String>,
}

fn main() {
    let stdin = io::stdin();

    for line in stdin.lock().lines() {
        let line = match line {
            Ok(l) => l,
            Err(_) => break,
        };

        if line.trim().is_empty() {
            continue;
        }

        let req: Request = match serde_json::from_str(&line) {
            Ok(r) => r,
            Err(_) => continue,
        };

        match req.action.as_str() {
            "sum" => {
                if req.params.len() != 2 {
                    send_error(&req.id, "invalid params");
                    continue;
                }

                let result = req.params[0] + req.params[1];
                send_ok(&req.id, result);
            }
            _ => send_error(&req.id, "unknown action"),
        }
    }
}

fn send_ok(id: &str, result: f64) {
    let resp = Response {
        id: id.to_string(),
        status: "ok".into(),
        result: Some(result),
        error: None,
    };

    println!("{}", serde_json::to_string(&resp).unwrap());
}

fn send_error(id: &str, msg: &str) {
    let resp: Response<()> = Response {
        id: id.to_string(),
        status: "error".into(),
        result: None,
        error: Some(msg.to_string()),
    };

    println!("{}", serde_json::to_string(&resp).unwrap());
}
```

**Dependencies**

```toml
[dependencies]
serde = { version = "1", features = ["derive"] }
serde_json = "1"
```

  </TabItem>
</Tabs>

---

## Folder Structure

The compiled binary must be placed inside the resource directory.

Supported locations:

```bash
resource/
  bin/
    win32/
      math.exe
```

```bash
resource/
  bin/
      math.exe
```

OpenCore resolves the correct path automatically and build the project with the binary file

---

## Error Handling

If the binary returns a response with:

```json
{ "status": "error" }
```

The corresponding TypeScript call is rejected with an `AppError`.

Errors can be handled normally using `try / catch`:

```ts
try {
  await math.sum(2, 3)
} catch (err) {
  // binary error
}
```

---

## Notes

- The binary must never write logs to `stdout`
- All logs should be written to `stderr`
- Each JSON message must be written on a single line
- The process must remain alive during execution

**Binary Services are language-agnostic.** Any programming language capable of producing a standalone executable and communicating through standard input/output is supported.

Examples include (but are not limited to):

- Go  
- Rust  
- C / C++  
- Zig  
- Nim  
- Crystal  
- Java (native image)  
- .NET (self-contained publish)  
- Python (compiled or embedded runtime)

Binary services are designed to be deterministic, isolated, and safe for production environments.
